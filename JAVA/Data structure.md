# Java 内存管理

> [!TIP]
> 堆内存、方法区、栈内存三者的关系：堆内存存放对象实例和数组，方法区存放类信息、常量、静态变量、即时编译器编译后的代码等数据，栈内存存放局部变量、方法调用、返回地址等信息。

- [Java 内存管理](#java-内存管理)
  - [内存模型](#内存模型)
  - [栈「Stack」](#栈stack)
  - [栈帧「stack frame」](#栈帧stack-frame)
  - [堆「Heap」](#堆heap)
  - [方法区/元空间「Method Area/Metadata Area」](#方法区元空间method-areametadata-area)
  - [本地方法区 「Native Method Area」](#本地方法区-native-method-area)
  - [寄存器 「Registers」](#寄存器-registers)
  - [程序计数器 「Program Counter」](#程序计数器-program-counter)
  - [直接内存映射 「Direct Memory Mapping」](#直接内存映射-direct-memory-mapping)
  - [总结](#总结)

## 内存模型

Java 内存模型（Memory Model）是 Java 平台内存管理的基础，它定义了程序中变量的访问规则，以及在多线程环境下对变量的访问的同步规则。

Java 内存模型规定了变量在内存中的存储布局，以及变量的访问规则。Java 内存模型定义了程序中变量的访问规则，包括变量的创建、分配、读写、释放等。Java 内存模型规定了变量的访问规则，包括变量的创建、分配、读写、释放等。

1. 变量的创建：在 Java 程序中，变量的创建是指在内存中为变量分配内存空间。

2. 变量的分配：Java 内存模型规定，变量的分配是指将变量存储在堆内存或方法区中。

3. 变量的读写：Java 内存模型规定，变量的读写是指对变量进行读写操作。

4. 变量的释放：Java 内存模型规定，变量的释放是指将不再使用的变量从内存中清除。

Java 内存模型规定，变量的创建、分配、读写、释放等操作必须满足一定的顺序，这就保证了 Java 程序的正确性。

## 栈「Stack」

> [!NOTE]
> 栈内存是线程私有的，生命周期与线程相同，存放局部变量、方法调用、返回地址等信息。
>
> 栈是方法执行时的内存空间，每个线程都有自己的栈，栈内存是线程私有的，生命周期与线程相同，栈去使用其他方法时也会开辟新的栈帧。当一个方法执行完毕，栈帧就会出栈，释放栈内存。栈自身运行结束后，也会自动释放。
>
> 栈是一种先进后出的数据结构，当一个方法调用另一个方法时，新的方法的栈帧将被压入栈顶，当该方法返回时，栈顶的栈帧将被弹出。

栈是一种先进后出的数据结构：**队列**「Queue」

栈内存的分配和回收都是自动的，无需程序员手动操作。

栈的**基本数据类型**：是存储在自己的空间中的变量<sup>`栈帧`</sup>，`int` `String` 等。

栈中的**引用数据类型**：数据值都是存储在**其他空间中**，自己空间中存储的是**引用地址值**

栈内存的分配：当线程执行一个方法时，JVM 会在栈内存中为该线程分配一个栈帧，用于存储局部变量、方法调用、返回地址等信息。

栈内存的回收：当线程执行结束时，JVM 会自动回收该线程的栈帧，释放栈内存。

栈帧：栈帧是 JVM 为每个方法调用创建的内存空间，用于存储局部变量、方法调用、返回地址等信息。

栈帧的大小：栈帧的大小是固定的，由编译器确定。

## 栈帧「stack frame」

> [!TIP]
> 栈帧 (stack frame) 是 Java 中一种临时数据结构，会在方法调用时于栈内存上创建。它充当方法的执行上下文，存储着方法运行所必需的信息。

| 组件     | 描述                                                                     |
| -------- | ------------------------------------------------------------------------ |
| 局部变量 | 在方法内部声明的变量，用于存储特定于方法执行的数据。                     |
| 方法参数 | 方法调用时传入的参数会存储在此处。                                       |
| 操作数栈 | 它充当方法的工作区，用于存放计算和操作中使用的操作数 (值)。              |
| 动态链接 | 该链接指向调用方法的栈帧，使得被调用的方法可以访问调用者上下文中的信息。 |
| 返回地址 | 此地址指定方法完成执行后继续执行的位置，确保程序能顺利返回到调用者处     |

> [!NOTE]
> 栈 即线程 私有 可以有多个栈帧，每个栈帧对应一个**`方法`**调用。
>
> 只有方法才拥有 `栈帧`，类中的属性、静态变量、局部变量都不拥有`栈帧`，在实例后才在`堆`内存中。
>
> 栈帧是用来记录 方法中的 局部变量 全局变量是在类中生命的，局部变量保存的方式就是 栈帧。`for` 循环等等只要有临时变量，`栈`就会去创建`栈帧`。在方法结束临时变量无用之后，栈帧自然也会被**回收**。
>
> 入口函数的栈帧是唯一的，它是程序的入口点，也是程序的起点。`main` 是方法，所以拥有栈帧。主程序进行的所有操作都是临时的，都在栈帧中。 `static` 方法 让属性强制存储在堆中。`main` 方法是栈帧。
>
> `static` 方法是 静态变量，`局部变量` 是 `栈帧`。默认情况 变量都是在栈中创建的。只有 `static` 变量才会存储到 `方法区` 中。`属性` 都是在堆中创建的。
>
> `静态变量/常量`：随类的加载 方法区读取 而存在，类卸载时消失。类加载时初始化一次，整个应用程序生命周期中都可以访问。
>
> `静态变量/常量`是存储在 `方法区` 当中的，实例变量是存储在 `堆` 中。也就是可以不实例化，直接通过类名访问。

## 堆「Heap」

> [!NOTE]
> 堆内存是 Java 虚拟机所管理的内存中最大的一块，栈内存存放局部变量、方法调用、返回地址等信息，堆内存存放**对象**和**数组**实例。
>
> 堆是存储对象实例和数组的区域，堆内存是共享的，所有线程<sup>`栈`</sup>都可以访问。
>
> `堆对象`拥有自己的地址，不同对象的地址值都不相同，每个堆都是不同的实例/数组。堆通常是 `new` 方法触发的，返回的对象都存放在堆中的地址。
>
> `堆对象` 堆中存储的都是动态类型数据，静态类型是由方法区存储。
>
> 动态：可以多态，可以变化，可以动态绑定。静态：编译时就确定了类型，不能变化，不能多态。
>
> **实例数据**（Instance Data）： 存储对象的具体字段值。
>
> **引用数据**（Reference Data）： 存储对象的引用值。

堆内存（Heap Memory）是 Java 虚拟机所管理的内存中最大的一块，用于存放对象实例和数组。堆内存是 JVM 所管理的内存中最大的一块，也是垃圾收集器管理的主要区域。堆内存的分配和回收都是自动的，无需程序员手动操作。

堆内存的分配：当程序创建对象或数组时，JVM 会在堆内存中为对象或数组分配内存空间。

堆内存的回收：当程序不再使用某个对象或数组时，JVM 会自动回收该对象或数组占用的内存空间。

`-Xms`：设置 Java 堆的初始大小

`-Xmx`：设置 Java 堆的最大可分配空间

## 方法区/元空间「Method Area/Metadata Area」

> [!NOTE]
> 方法区是 JVM 所管理的内存中第二大块，用于存放类信息、常量、静态变量、即时编译器编译后的代码等数据。堆是存储**对象**，它是存储**变量**等
>
> <h2>理解方法区</h2>
>
> 方法区是用来存储类信息、**常量**、**静态变量**、类中定义了变量，它就会存储在里面。栈读取运行类 完成的结果，最后变量值都是存储在`方法区`中的，对象是存储在`堆`中的。
>
> 类的方法区是独立的，父类只能调用自己的方法，变量。你实例化另一个类，也不能直接调用它方法。相反子类实例化，也不能直接拿到父类的变量，只能通过方法的参数传递实现通讯。
>
> 方法区数据拥有标识符<sup>`类对象`</sup> 必须通过标识符，才能让不同类的方法不会相互影响，保证类的数据安全。方法区存储的是类的结构，而不是具体数值，静态类型变量的值存储在方法区中，在实例化后才会去`堆`中存储具体数值，所以方法区是`静态`的，而堆是`动态`的。
>
> `栈` 运行后 它的动态数据 存储在堆中，在此之前它们 是完全不存在的，方法记录了这个有这个 `类、常量、静态变量、即时编译器编译后的代码` ，在类实例化的时候 `栈` 执行类中的代码。最后将结果存储在`堆`中。类中的 **动态属性、方法** 也是存储在`堆`中。而 `静态` `常量` 方法区初始化 加载类 的时候一并记录到方法区中。并且它只会在**类初始化**的时候加载一次。
>
> 类中的 静态类型 `static` 常量 `final` 都是类中的属性 存储在方法区中所以 可以直接 `类名.属性` 访问。方法区不会被回收。随程序生命周期。静态方法 也是！动态放到堆中。
>
> <hr>
>
> **类信息**（Class Information）： 包括类的完整类名、修饰符、父类、接口、方法、字段等信息。
>
> **常量**（Constants）： 包括字面值（例如，整型、浮点数、字符串）和符号引用（例如，类名、字段名、方法名）。存储在方法区
>
> **静态类型**（Static Variables）： 属于类而不是实例的变量。存储在方法区。
>
> **即时编译器**（JIT）编译后的代码： 即时编译器会将字节码编译为机器码，以提高程序的执行速度。方法区
>
> **方法区**（Method Area）： 全局内存 记录 不同类型|变量  所拥有的方法 堆实例化会更新。

方法区与 Java 堆不同，它不是用来存储对象的。方法区中的数据通常是**全局**的，并且在整个程序的生命周期中都存在。

方法区是 JVM 所管理的内存中第二大块，也是垃圾收集器管理的第二个区域。方法区的主要作用是存储类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区的分配：当程序加载类时，JVM 会在方法区中为类信息、常量、静态变量、即时编译器编译后的代码等数据分配内存空间。

方法区是 java 存储可以执行 class 文件的内存区域，栈、堆、方法区都是 JVM 运行时数据区

方法区的回收：当程序不再使用某个类时，JVM 会自动回收该类占用的内存空间。

`-XX:MaxPermSize`：设置方法区最大可分配空间

`-XX:PermSize`：设置方法区初始分配空间

## 本地方法区 「Native Method Area」

> [!NOTE]
> 本地方法区是 JVM 所管理的内存中第三大块，用于存放 native 方法栈。

本地方法区（Native Method Area）是 JVM 所管理的内存中第三大块，用于存放 native 方法栈。

native：指的是非 Java 语言编写的程序，如 C、C++、汇编语言等。

他们均是用来调用系统底层的方法接口，因此需要使用 native 方法区来存储 native 方法的栈。

## 寄存器 「Registers」

> [!NOTE]
> 寄存器是 CPU 内部的一小块高速缓存，用于存储 CPU 正在处理的数据和指令。与内存（RAM）相比，寄存器的访问速度要快得多，因此 CPU 可以更快地访问和处理存储在寄存器中的数据。

寄存器通常用于以下目的：

1. **存储指令**： 当 CPU 从内存中读取指令时，这些指令会首先存储在寄存器中。然后，CPU 可以从寄存器中快速地执行这些指令。

2. **存储数据**： CPU 在对数据进行运算时，会将数据存储在寄存器中。例如，如果 CPU 要将两个数字相加，则这两个数字会首先存储在寄存器中，然后 CPU 会从寄存器中取出这两个数字进行相加运算，并将结果存储回寄存器中。

3. **存储地址**： 寄存器还可以用于存储内存地址。例如，当 CPU 要访问内存中的某个数据项时，它会将该数据项的地址存储在寄存器中。然后，CPU 可以使用该地址来访问内存中的数据项。

由于寄存器访问速度很快，因此可以提高 CPU 的整体性能。但是，寄存器的数量是有限的，因此 CPU 必须谨慎地管理寄存器的使用。

在 Java 虚拟机（JVM）中，寄存器用于存储以下信息：

1. **程序计数器**（PC）： 存储当前正在执行的字节码指令的地址。

2. **操作数栈**： 存储指令的操作数和中间结果。

3. **局部变量表**： 存储方法的局部变量。

JVM 还使用寄存器来执行一些其他操作，例如：

1. **方法调用**： 当调用一个方法时，JVM 会使用寄存器来传递参数和保存返回地址。

2. **异常处理**： 当发生异常时，JVM 会使用寄存器来保存异常信息。

总而言之，寄存器是 CPU 的重要组成部分，用于存储 CPU 正在处理的数据和指令。寄存器访问速度很快，可以提高 CPU 的整体性能。在 Java 虚拟机中，寄存器用于存储程序计数器、操作数栈和局部变量表等信息，并执行方法调用和异常处理等操作。

## 程序计数器 「Program Counter」

> [!NOTE]
> 程序计数器（Program Counter）是一块很小的内存空间，它是当前线程所执行的字节码的行号指示器。

程序计数器的主要作用是跟踪当前正在执行的指令，并指示要执行的下一条指令。具体来说，程序计数器执行以下功能：

1. **存储当前正在执行的字节码指令的地址**： 程序计数器存储的是一条字节码指令的机器码地址，而不是字节码指令本身。

2. **指示要执行的下一条指令**： 当一条指令执行完成后，程序计数器会自动增加，指向下一条要执行的指令。

3. **支持分支、循环和跳转**： 程序计数器用于支持程序中的分支、循环和跳转等控制流结构。例如，在分支语句中，程序计数器会根据条件跳转到不同的指令地址。

程序计数器是一个非常重要的内存区域，它是 Java 虚拟机执行的核心部件之一。如果没有程序计数器，Java 虚拟机就无法确定要执行哪些指令，也无法控制程序的执行流程。

以下是一些关于程序计数器的额外信息：

1. 程序计数器是一个非常小的内存区域，通常只有几个字节大小。
2. 程序计数器是线程私有的，这意味着每个线程都拥有自己的程序计数器。
3. 程序计数器的值在程序运行过程中会不断改变。
4. 程序计数器由 Java 虚拟机指令控制，它不会被程序员显式访问或修改。

## 直接内存映射 「Direct Memory Mapping」

> [!NOTE]
> 直接内存映射（Direct Memory Mapping，简称 DMM）是一种由操作系统提供的内存管理机制，它允许应用程序将物理内存直接映射到其虚拟地址空间中
>
> 从而使应用程序能够像访问普通内存一样访问物理内存。DMM 可以绕过操作系统提供的缓存和页面错误处理机制，从而提高应用程序对物理内存的访问速度。

DMM 通常用于以下场景：

1. **访问 I/O 设备**： DMM 可以用于高效地访问 I/O 设备，例如图形卡、网络适配器和磁盘驱动器。

2. **共享内存**： DMM 可以用于在多个进程之间共享内存，而无需进行数据拷贝。

3. **内存映射文件**： DMM 可以用于将文件映射到内存中，从而使应用程序能够像访问普通内存一样访问文件内容。

DMM 具有以下优点：

1. **提高性能**： DMM 可以绕过操作系统提供的缓存和页面错误处理机制，从而提高应用程序对物理内存的访问速度。

2. **减少内存拷贝**： DMM 可以避免在应用程序和操作系统之间进行数据拷贝，从而提高应用程序的性能。

3. **简化编程**： DMM 可以使用户程序像访问普通内存一样访问物理内存，从而简化编程。

但是，DMM 也有一些缺点：

1. **增加内存使用**： DMM 会导致应用程序的内存使用增加，因为应用程序需要为映射的物理内存分配额外的内存空间。

2. **增加安全性风险**： DMM 可能会增加安全性风险，因为应用程序可以直接访问物理内存，包括其他应用程序的内存空间。

总而言之，DMM 是一种可以提高应用程序性能的技术，但它也存在一些缺点。在使用 DMM 之前，需要仔细权衡其利弊。

以下是一些关于 DMM 的额外信息：

- MM 在 Windows、Linux 和 macOS 等操作系统中都可用。

- DMM 通常由设备驱动程序支持。

- 一些数据库管理系统（DBMS）使用 DMM 来提高数据库性能。

在 Java 中，可以使用 `java.nio.channels.FileChannel` 类来实现 `DMMFileChannel` 类提供了 `map()` 方法，该方法可以将文件映射到内存中，并返回一个 `MappedByteBuffer` 对象。`MappedByteBuffer` 对象可以像普通缓冲区一样使用，用于读写文件内容。

## 总结

Java 内存模型定义了程序中变量的访问规则，包括变量的创建、分配、读写、释放等。Java 内存模型规定了变量的创建、分配、读写、释放等操作必须满足一定的顺序，这就保证了 Java 程序的正确性。

栈内存是线程私有的，生命周期与线程相同，存放局部变量、方法调用、返回地址等信息。栈是一种先进后出的数据结构，当一个方法调用另一个方法时，新的方法的栈帧将被压入栈顶，当该方法返回时，栈顶的栈帧将被弹出。

堆内存是 Java 虚拟机所管理的内存中最大的一块，用于存放对象实例和数组。堆内存是共享的，所有线程都可以访问。堆拥有自己的地址值，不同对象的地址值都不相同，每个堆都是不同的实例/数组。

方法区是 JVM 所管理的内存中第二大块，用于存放类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区的主要作用是存储类信息、常量、静态变量、即时编译器编译后的代码等数据。

本地方法区是 JVM 所管理的内存中第三大块，用于存放 native 方法栈。

寄存器是 CPU 内部的小容量存储器，用于临时存放数据。

程序计数器是一块很小的内存空间，它是当前线程所执行的字节码的行号指示器。程序计数器的主要作用是跟踪当前正在执行的指令，并指示要执行的下一条指令。
